#pragma once
#include <bits/stdc++.h>

#include "ambiguities.hpp"
#include "IdealMembershipStatus.hpp"
#include "reductions.hpp"

namespace ncgb {

// Struct for running the Buchberger algorithm
template<typename K, typename X, class ord>
struct BuchbergerIncremental {
  std::vector<Poly<K, X, ord>> G;
  std::vector<bool> removed;
  std::queue<std::tuple<Amb<X>, size_t, size_t>> ambs;
  size_t t = 0;

  // Construct an element with the generator set
  BuchbergerIncremental(std::vector<Poly<K, X, ord>> GG) {
    for (size_t i = 0; i < GG.size(); i++) {
      add_poly(GG[i]);
    }
  }

  void add_amb(Amb<X>& amb, size_t i, size_t j) {
    if (checkDeletionCriteria(G, amb, i, j)) {
      return;
    }

    ambs.push({std::move(amb), i, j});
  }

  void add_poly(const Poly<K, X, ord>& f) {
    G.push_back(f);
    removed.push_back(false);
    for (size_t k = 0; k < G.size() - 1; k++) if (!removed[k]) {
      for (auto& amb : ambiguities(G[k].lm(), f.lm())) {
        add_amb(amb, k, G.size() - 1);
      }
      for (auto& amb : ambiguities(f.lm(), G[k].lm())) {
        add_amb(amb, G.size() - 1, k);
      }
    }
  }

  // Compute the next polynomial in the Gröbner base, returns empty if G is already a Gröbner base
  std::optional<Poly<K, X, ord>> next() {
    if (t < G.size()) {
      Poly<K, X, ord> res = G[t];
      t++;
      return res;
    }
    while (!ambs.empty()) {
      auto [amb, i, j] = std::move(ambs.front());
      ambs.pop();

      Poly<K, X, ord> s = S_poly(amb, G[i], G[j]);
      reduce(s, G, removed);

      if (amb.type == Amb<X>::Inclusion) {
        removed[i] = true;
      }

      if (!s.isZero()) {
        add_poly(s);
        t++;
        return s;
      }

    }

    return {};
  }

  // Compute the full Gröbner base. If there is now finite base this function will not halt
  std::vector<Poly<K, X, ord>> fullBase() {
    while (next().has_value()) {}
    std::vector<Poly<K, X, ord>> res;
    for (size_t i = 0; i < G.size(); i++) if (!removed[i]) {
      res.push_back(G[i]);
    }
    return res;
  }
};

// Try yo check if f is in the ideal generated by G using st steps
template<typename K, typename X, class ord>
IdealMembershipStatus inIdeal(const std::vector<Poly<K, X, ord>>& G, Poly<K, X, ord> f, size_t st = 20) {
  BuchbergerIncremental<K, X, ord> bi(G);

  for (size_t i = G.size(); i < st; i++) {
    std::optional<Poly<K, X, ord>> p = bi.next();
    if (!p.has_value()) {
      return NotInIdeal;
    }
    reduce(f, bi.G);
    if (f.isZero()) {
      return InIdeal;
    }
  }

  return Unknown;
}

template<typename K, typename X, class ord>
std::tuple<Poly<K, X, ord>, std::tuple<Monomial<X>, Monomial<X>, K>, std::tuple<Monomial<X>, Monomial<X>, K>>
S_polyCofactor(const Amb<X>& amb, const Poly<K, X, ord>& f, const Poly<K, X, ord>& g) {
  Monomial<X> fa, fb, ga, gb;
  K fc, gc;
  if (amb.type == Amb<X>::Inclusion) {
    fc = K(1) / f.lc();
    ga = amb.a;
    gb = amb.b;
    gc = K(-1) / g.lc();
  } else {
    fb = amb.b;
    fc = K(1) / f.lc();
    ga = amb.a;
    gc = K(-1) / g.lc();
  }
  return {fa * f * fb * fc + ga * g * gb * gc, {fa, fb, fc}, {ga, gb, gc}};
}

// The same that before but getting the construction of the Gröbner base
// You get CofactorPoly's that are the construction of the polynomials in the Gröbner base
template<typename K, typename X, class ord>
struct BuchbergerIncrementalCofactor {
  std::vector<Poly<K, X, ord>> G;
  std::vector<CofactorPoly<K, X, ord>> G_rec;
  std::vector<bool> removed;
  std::queue<std::tuple<Amb<X>, size_t, size_t>> ambs;
  size_t t = 0;

  BuchbergerIncrementalCofactor(std::vector<Poly<K, X, ord>> GG) {
    for (size_t i = 0; i < GG.size(); i++) {
      CofactorPoly<K, X, ord> f_rec;
      f_rec.terms.push_back({Monomial<X>(), i, Monomial<X>(), K(1)});
      add_poly(GG[i], f_rec);
    }
  }

  void add_amb(Amb<X>& amb, size_t i, size_t j) {
    if (checkDeletionCriteria(G, amb, i, j)) {
      return;
    }

    ambs.push({std::move(amb), i, j});
  }

  void add_poly(const Poly<K, X, ord>& f, CofactorPoly<K, X, ord>& f_rec) {
    G.push_back(f);
    G_rec.push_back(std::move(f_rec));
    removed.push_back(false);
    for (size_t k = 0; k < G.size() - 1; k++) if (!removed[k]) {
      for (auto& amb : ambiguities(G[k].lm(), f.lm())) {
        add_amb(amb, k, G.size() - 1);
      }
      for (auto& amb : ambiguities(f.lm(), G[k].lm())) {
        add_amb(amb, G.size() - 1, k);
      }
    }
  }

  std::optional<Poly<K, X, ord>> next() {
    if (t < G.size()) {
      Poly<K, X, ord> res = G[t];
      t++;
      return res;
    }
    while (!ambs.empty()) {
      auto [amb, i, j] = std::move(ambs.front());
      ambs.pop();

      auto [s, gi_rec, gj_rec] = S_polyCofactor(amb, G[i], G[j]);
      CofactorPoly<K, X, ord> s_rec = reduceCofactor(s, G, G_rec, removed);

      if (amb.type == Amb<X>::Inclusion) {
        removed[i] = true;
      }

      if (!s.isZero()) {
        s_rec *= K(-1);
        auto& [ai, bi, ci] = gi_rec;
        auto& [aj, bj, cj] = gj_rec;
        s_rec += ai * G_rec[i] * bi * ci;
        s_rec += aj * G_rec[j] * bj * cj;
        add_poly(s, s_rec);
        t++;
        return s;
      }

    }

    return {};
  }

  std::vector<CofactorPoly<K, X, ord>> fullBase() {
    while (next().has_value()) {}
    std::vector<CofactorPoly<K, X, ord>> res;
    for (size_t i = 0; i < G.size(); i++) if (!removed[i]) {
      res.push_back(G_rec[i]);
    }
    return res;
  }
};

template<typename K, typename X, class ord>
std::pair<IdealMembershipStatus, std::optional<CofactorPoly<K, X, ord>>>
inIdealCofactor(const std::vector<Poly<K, X, ord>>& G, Poly<K, X, ord> f, size_t max_sz = 20) {
  BuchbergerIncrementalCofactor<K, X, ord> bi(G);

  CofactorPoly<K, X, ord> res;
  for (size_t i = G.size(); i < max_sz; i++) {
    std::optional<Poly<K, X, ord>> p = bi.next();
    if (!p.has_value()) {
      return {NotInIdeal, {}};
    }
    res += reduceCofactor(f, bi.G, bi.G_rec, bi.removed);
    if (f.isZero()) {
      return {InIdeal, res};
    }
  }

  return {Unknown, {}};
}

} // namespace ncgb
